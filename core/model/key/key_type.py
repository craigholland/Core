import base64
import calendar
import datetime
import os
import re
import string
import time
import urlparse

from core.core_error import *
from core.core_utils import typename
from core.model.core_model_utils import ValidateString

class Key(object):
  """The primary key for a datastore entity.

  A datastore GUID. A Key instance uniquely identifies an entity across all
  apps, and includes all information necessary to fetch the entity from the
  datastore with Get().

  Key implements __hash__, and key instances are immutable, so Keys may be
  used in sets and as dictionary keys.
  """
  __reference = None

  def __init__(self, encoded=None):
    """Constructor. Creates a Key from a string.

    Args:
      # a base64-encoded primary key, generated by Key.__str__
      encoded: str
    """
    self._str = None
    if encoded is not None:
      if not isinstance(encoded, basestring):
        try:
          repr_encoded = repr(encoded)
        except:
          repr_encoded = "<couldn't encode>"
        raise BadArgumentError(
          'Key() expects a string; received %s (a %s).' %
          (repr_encoded, typename(encoded)))
      try:
        # add padding back, if necessary
        modulo = len(encoded) % 4
        if modulo != 0:
          encoded += ('=' * (4 - modulo))

        # decode the Reference PB
        # Unicode cannot be base64 decoded directly, hence str().
        #
        # Note: This must be consistent across languages.  If it
        # changes, make sure that similar logic in Java changes as
        # well.  You will also need to update the golden test files.
        self._str = str(encoded)
        encoded_pb = base64.urlsafe_b64decode(self._str)
        # self.__reference = entity_pb.Reference(encoded_pb)
        # assert self.__reference.IsInitialized()


        # now we have to remove the padding from the cached string
        self._str = self._str.rstrip('=')

      except (AssertionError, TypeError), e:
        raise BadKeyError(
          'Invalid string key %s. Details: %s' % (encoded, e))
      except Exception, e:
        # NOTE(ryanb): ugh. ProtocolBuffer.py and the SWIG-wrapped C module
        # both provide a ProtocolBufferDecodeError, but python considers them
        # different types. 'except ProtocolBufferDecodeError' catches the
        # python one but not the C one. hence this monstrosity.
        # see http://b/1067354.
        if e.__class__.__name__ == 'ProtocolBufferDecodeError':
          raise BadKeyError('Invalid string key %s.' % encoded)
        else:
          raise
    else:
      # empty key
      #self.__reference = entity_pb.Reference()
    self.__reference = None #Some Reference object??
  def to_path(self, _default_id=None, _decode=True, _fail=True):
    """Construct the "path" of this key as a list.

    Returns:
      A list [kind_1, id_or_name_1, ..., kind_n, id_or_name_n] of the key path.

    Raises:
      datastore_errors.BadKeyError if this key does not have a valid path.
    """
    # Private args:
    #   _default_id: if provided, integer id to be applied if a key element
    #     doesn't contain neither id nor name, otherwise raise an
    #     datastore_errors.BadKeyError.
    #   _decode: if True, decode type and name assuming they are utf-8 encoded.
    #   _fail: on invalid utf-8: if True, raise error, if False return s
    def Decode(s):
      if _decode:
        try:
          return s.decode('utf-8')
        except UnicodeDecodeError:
          if _fail:
            raise
      return s

    path = []
    for path_element in self.__reference.path().element_list():
      path.append(Decode(path_element.type()))
      if path_element.has_name():
        path.append(Decode(path_element.name()))
      elif path_element.has_id():
        path.append(path_element.id())
      elif _default_id is not None:
        path.append(_default_id)
      else:
        raise BadKeyError('Incomplete key found in to_path')
    return path

  @staticmethod
  def from_path(*args, **kwds):
    """Static method to construct a Key out of a "path" (kind, id or name, ...).

    This is useful when an application wants to use just the id or name portion
    of a key in e.g. a URL, where the rest of the URL provides enough context to
    fill in the rest, i.e. the app id (always implicit), the entity kind, and
    possibly an ancestor key. Since ids and names are usually small, they're
    more attractive for use in end-user-visible URLs than the full string
    representation of a key.

    Args:
      kind: the entity kind (a str or unicode instance)
      id_or_name: the id (an int or long) or name (a str or unicode instance)
      parent: optional parent Key; default None.
      namespace: optional namespace to use otherwise namespace_manager's
        default namespace is used.

    Returns:
      A new Key instance whose .kind() and .id() or .name() methods return
      the *last* kind and id or name positional arguments passed.

    Raises:
      BadArgumentError for invalid arguments.
      BadKeyError if the parent key is incomplete.
    """
    # Extract keyword args
    parent = kwds.pop('parent', None)
    # _app is not documented; see datastore.Entity
    #app_id = ResolveAppId(kwds.pop('_app', None))
    app_id = kwds.pop('_app', None)

    # Use the parent namespace if parent is specified and
    # namespace is not specified.  This is validated later.
    namespace = kwds.pop('namespace', None)

    # Insist those were the only two keyword args
    if kwds:
      raise BadArgumentError(
          'Excess keyword arguments ' + repr(kwds))

    # Insist on one or more (kind, id/name) pairs as positional args
    if not args or len(args) % 2:
      raise BadArgumentError(
          'A non-zero even number of positional arguments is required '
          '(kind, id or name, kind, id or name, ...); received %s' % repr(args))

    # Type-check parent
    if parent is not None:
      if not isinstance(parent, Key):
        raise BadArgumentError(
            'Expected None or a Key as parent; received %r (a %s).' %
            (parent, typename(parent)))
      if namespace is None:
        namespace = parent.namespace()
      if not parent.has_id_or_name():
        raise BadKeyError(
            'The parent Key is incomplete.')
      if app_id != parent.app() or namespace != parent.namespace():
        raise BadArgumentError(
            'The app/namespace arguments (%s/%s) should match '
            'parent.app/namespace() (%s/%s)' %
            (app_id, namespace, parent.app(), parent.namespace()))

    # Go find a namespace if it's not specified and validate namespace.
    # namespace = ResolveNamespace(namespace)

    # Construct a Key from the parent and/or the app id
    key = Key()
    ref = key.__reference
    if parent is not None:
      ref.CopyFrom(parent.__reference)
    else:
      ref.set_app(app_id)

      #SetNamespace(ref, namespace)

    # Add the (kind, id/name) pairs, while typechecking them
    # TODO(bslatkin): Optimize this section
    path = ref.mutable_path()
    for i in xrange(0, len(args), 2):
      kind, id_or_name = args[i:i+2]
      if isinstance(kind, basestring):
        kind = kind.encode('utf-8')
      else:
        raise BadArgumentError(
            'Expected a string kind as argument %d; received %r (a %s).' %
            (i + 1, kind, typename(kind)))
      elem = path.add_element()
      elem.set_type(kind)
      if isinstance(id_or_name, (int, long)):
        elem.set_id(id_or_name)
      elif isinstance(id_or_name, basestring):
        ValidateString(id_or_name, 'name')
        elem.set_name(id_or_name.encode('utf-8'))
      else:
        raise BadArgumentError(
            'Expected an integer id or string name as argument %d; '
            'received %r (a %s).' % (i + 2, id_or_name, typename(id_or_name)))

    # One final check, and we're all set
    assert ref.IsInitialized()
    return key

  def app(self):
    """Returns this entity's app id, a string."""
    if self.__reference.app():
      return self.__reference.app().decode('utf-8')
    else:
      return None

  def namespace(self):
    """Returns this entity's namespace, a string."""
    if self.__reference.has_name_space():
      return self.__reference.name_space().decode('utf-8')
    else:
      return ''  # If None is used as a namespace parameter it is
                 # converted to the "current" namespace. Hence
                 # we cannot return None.

  def kind(self):
    """Returns this entity's kind, as a string."""
    if self.__reference.path().element_size() > 0:
      encoded = self.__reference.path().element_list()[-1].type()
      return unicode(encoded.decode('utf-8'))
    else:
      return None

  def id(self):
    """Returns this entity's id, or None if it doesn't have one."""
    elems = self.__reference.path().element_list()
    if elems and elems[-1].has_id() and elems[-1].id():
      return elems[-1].id()
    else:
      return None

  def name(self):
    """Returns this entity's name, or None if it doesn't have one."""
    elems = self.__reference.path().element_list()
    if elems and elems[-1].has_name() and elems[-1].name():
      return elems[-1].name().decode('utf-8')
    else:
      return None

  def id_or_name(self):
    """Returns this entity's id or name, whichever it has, or None."""
    if self.id() is not None:
      return self.id()
    else:
      # may be None
      return self.name()

  def has_id_or_name(self):
    """Returns True if this entity has an id or name, False otherwise.
    """
    elems = self.__reference.path().element_list()
    if elems:
      e = elems[-1]
      return bool(e.name() or e.id())
    else:
      return False

  def parent(self):
    """Returns this entity's parent, as a Key. If this entity has no parent,
    returns None."""
    if self.__reference.path().element_size() > 1:
      parent = Key()
      parent.__reference.CopyFrom(self.__reference)
      del parent.__reference.path().element_list()[-1]
      return parent
    else:
      return None

  # TEMP-REMOVE: returns None
  def ToTagUri(self):
    """Returns a tag: URI for this entity for use in XML output.

    Foreign keys for entities may be represented in XML output as tag URIs.
    RFC 4151 describes the tag URI scheme. From http://taguri.org/:

      The tag algorithm lets people mint - create - identifiers that no one
      else using the same algorithm could ever mint. It is simple enough to do
      in your head, and the resulting identifiers can be easy to read, write,
      and remember. The identifiers conform to the URI (URL) Syntax.

    Tag URIs for entities use the app's auth domain and the date that the URI
     is generated. The namespace-specific part is <kind>[<key>].

    For example, here is the tag URI for a Kitten with the key "Fluffy" in the
    catsinsinks app:

      tag:catsinsinks.googleapps.com,2006-08-29:Kitten[Fluffy]

    Raises a BadKeyError if this entity's key is incomplete.
    """
    # if not self.has_id_or_name():
    #   raise BadKeyError(
    #     'ToTagUri() called for an entity with an incomplete key.')
    #
    # return u'tag:%s.%s,%s:%s[%s]' % (
    #     #TODO(schefflerjens): can we somehow "unmangle" this?
    #     saxutils.escape(EncodeAppIdNamespace(self.app(), self.namespace())),
    #     os.environ['AUTH_DOMAIN'],
    #     datetime.date.today().isoformat(),
    #     saxutils.escape(self.kind()),
    #     saxutils.escape(str(self)))
    return None

  ToXml = ToTagUri

  def entity_group(self):
    """Returns this key's entity group as a Key.

    Note that the returned Key will be incomplete if this Key is for a root
    entity and it is incomplete.
    """
    group = Key._FromPb(self.__reference)
    del group.__reference.path().element_list()[1:]
    return group

  # TEMP-REMOVE: returns None
  @staticmethod
  def _FromPb(pb):
    """Static factory method. Creates a Key from an entity_pb.Reference.

    Not intended to be used by application developers. Enforced by hiding the
    entity_pb classes.

    Args:
      pb: entity_pb.Reference
    """
    # if not isinstance(pb, entity_pb.Reference):
    #   raise BadArgumentError(
    #     'Key constructor takes an entity_pb.Reference; received %s (a %s).' %
    #     (pb, typename(pb)))
    #
    # key = Key()
    # key.__reference = entity_pb.Reference()
    # key.__reference.CopyFrom(pb)  # defensive copy
    # return key
    return None

  # TEMP-REMOVE: returns None
  def _ToPb(self):
    """Converts this Key to its protocol buffer representation.

    Not intended to be used by application developers. Enforced by hiding the
    entity_pb classes.

    Returns:
      # the Reference PB representation of this Key
      entity_pb.Reference
    """
    # pb = entity_pb.Reference()
    # pb.CopyFrom(self.__reference)
    #
    # # strings in the reference should already be UTF-8. check this by
    # # attempting to decode them.
    # pb.app().decode('utf-8')
    # for pathelem in pb.path().element_list():
    #   pathelem.type().decode('utf-8')
    #
    # return pb

  def __str__(self):
    """Encodes this Key as an opaque string.

    Returns a string representation of this key, suitable for use in HTML,
    URLs, and other similar use cases. If the entity's key is incomplete,
    raises a BadKeyError.

    Unfortunately, this string encoding isn't particularly compact, and its
    length varies with the length of the path. If you want a shorter identifier
    and you know the kind and parent (if any) ahead of time, consider using just
    the entity's id or name.

    Returns:
      string
    """
    # Note: This must be consistent across languages.  If it changes,
    # make sure that similar logic in Java changes as well.  You will
    # also need to update the golden test files.
    try:
      if self._str is not None:
        return self._str
    except AttributeError:
      pass
    if (self.has_id_or_name()):
      encoded = base64.urlsafe_b64encode(self.__reference.Encode())
      self._str = encoded.replace('=', '')  # strip padding
    else:
      raise BadKeyError(
        'Cannot string encode an incomplete key!\n%s' % self.__reference)
    return self._str


  def __repr__(self):
    """Returns an eval()able string representation of this key.

    Returns a Python string of the form 'datastore_types.Key.from_path(...)'
    that can be used to recreate this key.

    Returns:
      string
    """
    args = []
    for elem in self.__reference.path().element_list():
      args.append(repr(elem.type().decode('utf-8')))
      if elem.has_name():
        args.append(repr(elem.name().decode('utf-8')))
      else:
        args.append(repr(elem.id()))  # this will be 0 if there's no id

    args.append('_app=%r' % self.__reference.app().decode('utf-8'))
    if self.__reference.has_name_space():
      args.append('namespace=%r' %
          self.__reference.name_space().decode('utf-8'))
    return u'datastore_types.Key.from_path(%s)' % ', '.join(args)

  def __cmp__(self, other):
    """Returns negative, zero, or positive when comparing two keys.

    TODO(ryanb): for API v2, we should change this to make incomplete keys, ie
    keys without an id or name, not equal to any other keys.

    Args:
      other: Key to compare to.

    Returns:
      Negative if self is less than "other"
      Zero if "other" is equal to self
      Positive if self is greater than "other"
    """
    if not isinstance(other, Key):
      return -2

    self_args = [self.__reference.app(), self.__reference.name_space()]
    self_args += self.to_path(_default_id=0, _decode=False)

    other_args = [other.__reference.app(), other.__reference.name_space()]
    other_args += other.to_path(_default_id=0, _decode=False)

    for self_component, other_component in zip(self_args, other_args):
      comparison = cmp(self_component, other_component)
      if comparison != 0:
        return comparison

    return cmp(len(self_args), len(other_args))

  def __hash__(self):
    """Returns an integer hash of this key.

    Implements Python's hash protocol so that Keys may be used in sets and as
    dictionary keys.

    Returns:
      int
    """
    args = self.to_path(_default_id=0, _fail=False)
    args.append(self.__reference.app())
    return hash(type(args)) ^ hash(tuple(args))
